module Reflect
exports all
definitions
types
	Name = seq1 of char;

/**
 * Types
 */
	BasicType = <NAT> | <NAT1> | <INT> | <RAT> | <REAL> | <CHAR> | <BOOL> | <TOKEN>;
	
	QuoteType ::
		kind	: Name;
		
	OptionalType ::
		type	: Type;
	
	SetSeqType ::
		kind	: <SET> | <SET1> | <SEQ> | <SEQ1>
		type	: Type;
		
	MapType ::
		inject	: bool
		domain	: Type
		range	: Type;
		
	ProductType ::
		members	: seq1 of Type;
		
	UnionType ::
		members	: seq1 of Type;
		
	NamedType ::
		name	: Name;
		
	ClassType ::
		name	: Name;
		
	Field ::
		name	: Name
		type	: Type;
		
	RecordType ::
		name	: Name
		fields	: seq of Field;
		
	FunctionType ::
		params	: seq of Type
		result	: Type;
	
	OperationType ::
		params	: seq of Type
		result	: Type;
	
	Type = BasicType | QuoteType | OptionalType | SetSeqType | MapType | ProductType | UnionType |
		   NamedType | RecordType | FunctionType | OperationType;

/**
 * Definitions
 */
	TypeDefinition ::
		name	: Name		-- LHS
		type	: Type;		-- RHS
		
	FunctionDefinition ::
		name	: Name
		type	: FunctionType;
				
	OperationDefinition ::
		name	: Name
		type	: OperationType;
				
	Definition = TypeDefinition | FunctionDefinition | OperationDefinition;
	
	Module = seq of Definition;
	
	Class = seq of Definition;
	
functions
	getDefinition: seq1 of char +> Definition
	getDefinition(name) ==
		is not yet specified;

end Reflect